/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.mydsl.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.xtext.example.mydsl.myDsl.MyDslPackage
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.MapBasedScope
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.resource.IEObjectDescription
import org.xtext.example.mydsl.myDsl.Use
import org.xtext.example.mydsl.myDsl.Library
import org.xtext.example.mydsl.myDsl.Function

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class MyDslScopeProvider extends AbstractMyDslScopeProvider {
	
	/**
	 * This function provides IEObjectDescription for every every Function that is
	 * (i.e. the Function and a QualifiedName that is shown in the content-assistant)
	 * a) directly referenced in the elements list of the provide function <via>
	 * b) referenced by any Library in its elements list (this relation is transitive)
	 * */
	private def Iterable<IEObjectDescription> describeAllAccessibleFunctions(Library via, QualifiedName pkgname){
		val directlyAccessibleFunctions = via.elements.filter(Function)
		var libraries =  via.elements.filter(Library)
// Get IEObjectDescriptions for all Functions (i.e. how the QualifiedName for the referenced Function looks like )
		Scopes.scopedElementsFor(directlyAccessibleFunctions, [pkgname.append(name)])
// recurse into all references to Libraries, but append the current Library name to the QualifiedName
// that is displayed on proposed Elements
		+ libraries.map[describeAllAccessibleFunctions(pkgname.append(name))].flatten
	}
	
	override getScope(EObject context, EReference reference) {		
		if (context instanceof Use && reference == MyDslPackage.Literals.USE__ELEMENT) {
			val root = EcoreUtil2.getRootContainer(context)
			val allLibraries = EcoreUtil2.getAllContentsOfType(root, Library)
			// only functions of composed in libraries are in scope
			val descriptions = allLibraries.map[describeAllAccessibleFunctions(QualifiedName.create(name))].flatten
			//Create new MapBasedScope based on the descriptions
			return MapBasedScope.createScope(IScope.NULLSCOPE, descriptions, false)
		}
		return super.getScope(context, reference);
	}
}
